/**
 * PR Template Service
 * Renders GitHub PR templates using Handlebars with issue links,
 * agent execution summaries, and changed files
 */

import Handlebars from 'handlebars';
import { readFile } from 'fs/promises';
import { existsSync } from 'fs';
import { join } from 'path';
import type {
  PRTemplateContext,
  PRTemplateConfig,
  PRTemplateResult,
  PRIssueData,
  PRExecutionData,
  PRChangesData,
  PRMetadata,
  PRExternalLink,
} from '../types/pr-template';
import type { Issue, ExternalIssueLink } from '../types/issue';
import type { AgentExecution } from '../lib/db';

/**
 * Default PR template (Markdown with Handlebars syntax)
 */
const DEFAULT_TEMPLATE = `## Summary

{{#if issue.description}}
{{issue.description}}
{{else}}
Implements: **{{issue.title}}**
{{/if}}

{{#if issue.externalLinks.length}}
### Related Issues
{{#each issue.externalLinks}}
- [{{provider}}: {{externalId}}]({{url}})
{{/each}}
{{/if}}

## Changes

{{#if changes}}
### Modified Files ({{changes.files.length}})
{{#each changes.files}}
- \`{{this}}\`
{{/each}}

{{#if changes.summary}}
### Summary
{{{changes.summary}}}
{{/if}}
{{/if}}

{{#if execution}}
## Agent Execution Summary

- **Status**: {{execution.status}}
- **Branch**: \`{{execution.gitBranch}}\`
{{#if execution.gitCommitHash}}
- **Commit**: \`{{execution.gitCommitHash}}\`
{{/if}}
{{#if execution.filesChanged}}
- **Files Changed**: {{execution.filesChanged}}
{{/if}}
{{#if execution.linesAdded}}
- **Lines Added**: +{{execution.linesAdded}}
{{/if}}
{{#if execution.linesDeleted}}
- **Lines Deleted**: -{{execution.linesDeleted}}
{{/if}}
{{#if execution.duration}}
- **Duration**: {{formatDuration execution.duration}}
{{/if}}
{{/if}}

## Testing Checklist

- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed
- [ ] Documentation updated

## Deployment Notes

{{#if metadata.baseBranch}}
Merging into: \`{{metadata.baseBranch}}\`
{{/if}}

---
*Generated by Jellos Agent on {{formatDate metadata.timestamp}}*
*Priority: {{uppercase issue.priority}}*
`;

/**
 * PR Template Service
 */
export class PRTemplateService {
  private handlebars: typeof Handlebars;
  private config: Required<PRTemplateConfig>;

  constructor(config?: PRTemplateConfig) {
    this.handlebars = Handlebars.create();
    this.registerHelpers();

    // Default configuration
    this.config = {
      templatePath: config?.templatePath,
      useDefaultTemplate: config?.useDefaultTemplate ?? true,
      includeIssueLinks: config?.includeIssueLinks ?? true,
      includeExecutionSummary: config?.includeExecutionSummary ?? true,
      includeChangedFiles: config?.includeChangedFiles ?? true,
      includeDiffStats: config?.includeDiffStats ?? true,
      maxFilesListed: config?.maxFilesListed ?? 50,
    };
  }

  /**
   * Register Handlebars helpers
   */
  private registerHelpers(): void {
    // Format date helper
    this.handlebars.registerHelper('formatDate', (date: Date | string) => {
      if (!date) return 'N/A';
      const d = typeof date === 'string' ? new Date(date) : date;
      return d.toISOString().split('T')[0]; // YYYY-MM-DD
    });

    // Format duration helper (milliseconds to human readable)
    this.handlebars.registerHelper('formatDuration', (ms: number) => {
      if (!ms) return 'N/A';
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);

      if (hours > 0) {
        return `${hours}h ${minutes % 60}m`;
      } else if (minutes > 0) {
        return `${minutes}m ${seconds % 60}s`;
      } else {
        return `${seconds}s`;
      }
    });

    // Uppercase helper
    this.handlebars.registerHelper('uppercase', (str: string) => {
      return str?.toUpperCase() || '';
    });

    // Conditional equals helper
    this.handlebars.registerHelper('eq', (a: any, b: any) => {
      return a === b;
    });

    // Truncate helper
    this.handlebars.registerHelper('truncate', (str: string, length: number) => {
      if (!str) return '';
      if (str.length <= length) return str;
      return str.substring(0, length) + '...';
    });
  }

  /**
   * Render PR template with provided context
   */
  async render(context: PRTemplateContext): Promise<PRTemplateResult> {
    // Load template
    const templateSource = await this.loadTemplate();

    // Compile template
    const template = this.handlebars.compile(templateSource, {
      noEscape: false, // Auto-escape HTML by default for XSS prevention
      strict: false, // Allow missing properties
    });

    // Filter context based on config
    const filteredContext = this.filterContext(context);

    // Render template
    const body = template(filteredContext);

    // Generate title
    const title = this.generateTitle(context);

    // Generate labels
    const labels = this.generateLabels(context);

    return {
      title,
      body: body.trim(),
      labels,
    };
  }

  /**
   * Load template from file or use default
   */
  private async loadTemplate(): Promise<string> {
    // Try custom template path first
    if (this.config.templatePath && existsSync(this.config.templatePath)) {
      try {
        return await readFile(this.config.templatePath, 'utf-8');
      } catch (error) {
        console.warn(
          `Failed to load custom template from ${this.config.templatePath}, falling back to default`,
          error
        );
      }
    }

    // Try .github/pull_request_template.md
    const githubTemplatePath = join(process.cwd(), '.github', 'pull_request_template.md');
    if (existsSync(githubTemplatePath)) {
      try {
        return await readFile(githubTemplatePath, 'utf-8');
      } catch (error) {
        console.warn(
          `Failed to load GitHub template from ${githubTemplatePath}, falling back to default`,
          error
        );
      }
    }

    // Use default template
    return DEFAULT_TEMPLATE;
  }

  /**
   * Filter context based on configuration
   */
  private filterContext(context: PRTemplateContext): Partial<PRTemplateContext> {
    const filtered: Partial<PRTemplateContext> = {
      issue: { ...context.issue },
      metadata: { ...context.metadata },
    };

    // Filter external links
    if (!this.config.includeIssueLinks) {
      filtered.issue!.externalLinks = [];
    }

    // Filter execution summary
    if (!this.config.includeExecutionSummary) {
      filtered.execution = undefined;
    } else if (context.execution) {
      filtered.execution = { ...context.execution };
    }

    // Filter changes
    if (!this.config.includeChangedFiles) {
      filtered.changes = undefined;
    } else if (context.changes) {
      // Limit number of files
      const files = context.changes.files.slice(0, this.config.maxFilesListed);
      filtered.changes = {
        ...context.changes,
        files,
      };
    }

    // Filter diff stats
    if (!this.config.includeDiffStats && filtered.execution) {
      delete filtered.execution.filesChanged;
      delete filtered.execution.linesAdded;
      delete filtered.execution.linesDeleted;
    }

    return filtered;
  }

  /**
   * Generate PR title from issue
   */
  private generateTitle(context: PRTemplateContext): string {
    const { issue, execution } = context;

    // Format: feat(ISSUE-123): Issue title
    const prefix = this.inferChangeType(issue.title, execution);
    const issueKey = issue.externalLinks[0]?.externalId || issue.id;

    return `${prefix}(${issueKey}): ${issue.title}`;
  }

  /**
   * Infer change type from issue title and execution
   */
  private inferChangeType(title: string, execution?: PRExecutionData): string {
    const lowerTitle = title.toLowerCase();

    if (lowerTitle.includes('feat') || lowerTitle.includes('feature')) {
      return 'feat';
    }
    if (lowerTitle.includes('fix') || lowerTitle.includes('bug')) {
      return 'fix';
    }
    if (lowerTitle.includes('docs') || lowerTitle.includes('documentation')) {
      return 'docs';
    }
    if (lowerTitle.includes('refactor')) {
      return 'refactor';
    }
    if (lowerTitle.includes('test')) {
      return 'test';
    }
    if (lowerTitle.includes('chore')) {
      return 'chore';
    }
    if (lowerTitle.includes('perf') || lowerTitle.includes('performance')) {
      return 'perf';
    }

    // Default to feat
    return 'feat';
  }

  /**
   * Generate labels based on issue and execution
   */
  private generateLabels(context: PRTemplateContext): string[] {
    const labels: string[] = [];

    // Add priority label
    if (context.issue.priority) {
      labels.push(`priority:${context.issue.priority.toLowerCase()}`);
    }

    // Add change type label
    const changeType = this.inferChangeType(
      context.issue.title,
      context.execution
    );
    labels.push(changeType);

    // Add automated label
    if (context.execution) {
      labels.push('automated');
    }

    return labels;
  }

  /**
   * Build template context from issue and execution
   */
  static buildContext(
    issue: Issue & { externalLinks?: ExternalIssueLink[] },
    execution?: AgentExecution,
    changes?: PRChangesData,
    metadata?: Partial<PRMetadata>
  ): PRTemplateContext {
    // Map issue data
    const issueData: PRIssueData = {
      id: issue.id,
      title: issue.title,
      description: issue.description,
      priority: issue.priority,
      externalLinks: (issue.externalLinks || []).map((link) => ({
        provider: link.provider.toUpperCase(),
        externalId: link.externalId,
        url: link.externalUrl,
      })),
    };

    // Map execution data
    let executionData: PRExecutionData | undefined;
    if (execution) {
      const duration =
        execution.startedAt && execution.completedAt
          ? execution.completedAt.getTime() - execution.startedAt.getTime()
          : undefined;

      executionData = {
        id: execution.id,
        status: execution.status,
        startedAt: execution.startedAt || undefined,
        completedAt: execution.completedAt || undefined,
        exitCode: execution.exitCode || undefined,
        gitCommitHash: execution.gitCommitHash || undefined,
        gitCommitMsg: execution.gitCommitMsg || undefined,
        gitBranch: execution.gitBranch || undefined,
        filesChanged: execution.filesChanged || undefined,
        linesAdded: execution.linesAdded || undefined,
        linesDeleted: execution.linesDeleted || undefined,
        duration,
      };
    }

    // Build metadata
    const prMetadata: PRMetadata = {
      branch: execution?.gitBranch || metadata?.branch || 'unknown',
      baseBranch: metadata?.baseBranch || 'main',
      author: metadata?.author,
      timestamp: new Date(),
      repoOwner: metadata?.repoOwner,
      repoName: metadata?.repoName,
    };

    return {
      issue: issueData,
      execution: executionData,
      changes,
      metadata: prMetadata,
    };
  }

  /**
   * Update configuration
   */
  updateConfig(config: Partial<PRTemplateConfig>): void {
    this.config = { ...this.config, ...config };
  }
}

// Singleton instance
let prTemplateServiceInstance: PRTemplateService | null = null;

export function getPRTemplateService(config?: PRTemplateConfig): PRTemplateService {
  if (!prTemplateServiceInstance || config) {
    prTemplateServiceInstance = new PRTemplateService(config);
  }
  return prTemplateServiceInstance;
}

export function resetPRTemplateService(): void {
  prTemplateServiceInstance = null;
}
